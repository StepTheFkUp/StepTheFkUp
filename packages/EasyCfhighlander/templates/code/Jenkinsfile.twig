@Library('ciinabox') _

def slackInfo(message){
  slackSend color: '#7dc141', channel: '#{{ project }}-ops', message: "${env.JOB_NAME} - ${env.BUILD_URL} | ${message}"
}
def slackWarning(message){
  slackSend color: '#ffc300', channel: '#{{ project }}-ops', message: "${env.JOB_NAME} - ${env.BUILD_URL} | ${message}"
}
def slackError(message){
  slackSend color: '#e80d4b', channel: '#{{ project }}-ops', message: "${env.JOB_NAME} - ${env.BUILD_URL} | ${message}"
}

pipeline {
  environment {
    AWS_REGION = '{{ aws_region }}'
    ECR_REPO = '{{ code.ecr_repo }}'
    PROJECT_NAME = '{{ project }}'
    SOURCE_BUCKET = '{{ source_bucket }}'
    DEV_ACCOUNT_ID = '{{ dev_account }}'
    PROD_ACCOUNT_ID = '{{ prod_account }}'
    CIINABOX_ROLE = '{{ ciinabox_role }}'
    BUILD_VER = "${env.BRANCH}-${env.GIT_COMMIT.substring(0,7)}"
    DNS_DOMAIN = "{{ dns_domain }}"
  }
  parameters {
    booleanParam(name: 'UPDATE_SCHEMA_TASK_DEF', defaultValue: false, description: 'Update Schema Task Def')
    booleanParam(name: 'UPDATE_SCHEMA', defaultValue: true, description: 'Update Schema Task Def')
  }
  agent {
    node {
      label 'docker'
    }
  }
  options { disableConcurrentBuilds() }
  stages {
    stage('Prepare the build') {
        steps {
            sh "aws s3 cp s3://${SOURCE_BUCKET}/scripts/auth.json auth.json"
        }
    }
    stage('Build containers') {
        steps {
            parallel(
                "Build api": {
                    dockerBuild repo: env.ECR_REPO,
                    image: "${env.PROJECT_NAME}/backend",
                    dir: './',
                    dockerfile: 'docker/api/Dockerfile',
                    tags: [env.GIT_COMMIT, env.BUILD_NUMBER, 'latest'],
                    push: true,
                    cleanup: true
                },
                "Build nginx": {
                    dockerBuild repo: env.ECR_REPO,
                    image: "${env.PROJECT_NAME}/nginx",
                    dir: './',
                    dockerfile: 'docker/nginx/Dockerfile',
                    tags: [env.GIT_COMMIT, env.BUILD_NUMBER, 'latest'],
                    push: true,
                    cleanup: true
                }
            )
        }
    }
    stage('Compile and Validate') {
      agent {
        docker {
          image 'theonestack/cfhighlander'
          reuseNode true
        }
      }
      steps {
        sh "cfhighlander cfcompile ${env.PROJECT_NAME} --validate"
        sh "cfhighlander cfcompile ${env.PROJECT_NAME}-schema --validate"
      }
    }
    stage('Publish') {
      agent {
        docker {
          image 'theonestack/cfhighlander'
          reuseNode true
        }
      }
      steps {
        script {
            println "env:${env.GIT_COMMIT}"
            env['cf_version'] = env.BRANCH_NAME
            env['project_name'] = env.PROJECT_NAME
            env['BRANCH'] = env.BRANCH_NAME
            env['SHORT_COMMIT'] = env.GIT_COMMIT.substring(0,7)
            if(env.BRANCH_NAME == 'master') {
                env['cf_version'] = "master-${env.SHORT_COMMIT}"
            }
        }
        sh "env && cfhighlander cfpublish ${env.PROJECT_NAME} --version ${env.cf_version} --dstbucket ${env.SOURCE_BUCKET} --dstprefix cloudformation/${env.PROJECT_NAME}"
        sh "env && cfhighlander cfpublish ${env.PROJECT_NAME}-schema --version ${env.cf_version} --dstbucket ${env.SOURCE_BUCKET} --dstprefix cloudformation/${env.PROJECT_NAME}-schema"
      }
    }
    stage('Update Dev Schema Environment') {
      when {
        expression { (env.BRANCH_NAME == 'development') && params.UPDATE_SCHEMA_TASK_DEF == true }
      }
      steps {
        println "Update Schema Task Def Dev Environment"
        sh "export"
        cloudformation(
          stackName: 'dev-{{ project }}-schema',
          action: 'create',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}-schema/${env.cf_version}/${env.PROJECT_NAME}-schema.compiled.yaml",
          accountId: env.DEV_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'EnvironmentName': 'dev',
            'EnvironmentType': 'development'
          ]
        )
        cloudformation(
          stackName: 'dev-{{ project }}-schema',
          action: 'update',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}-schema/${env.cf_version}/${env.PROJECT_NAME}-schema.compiled.yaml",
          accountId: env.DEV_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'EnvironmentName': 'dev',
            'EnvironmentType': 'development'
          ]
        )
      }
    }
    stage('Update Dev Schema') {
      environment {
        ENV = "dev"
      }
      when {
        expression { (env.BRANCH_NAME == 'development') && params.UPDATE_SCHEMA == true }
      }
      steps {
        println "Updating Schema"
        sh '''
        #!/bin/bash
        aws s3 cp s3://${SOURCE_BUCKET}/scripts/ecs-run.sh ecs-run.sh
        chmod +x ./ecs-run.sh
        '''
        withAWS(roleAccount:env.DEV_ACCOUNT_ID, region:env.AWS_REGION, role:env.CIINABOX_ROLE) {
          script {
            def task_def = sh returnStdout: true, script: "aws cloudformation list-exports --query 'Exports[?Name==`${ENV}-{{ project }}-schema-task-EcsTaskArn`].Value' --output text --region ${AWS_REGION}"
            def cluster = sh returnStdout: true, script: "aws cloudformation list-exports --query 'Exports[?Name==`${ENV}-ecs-EcsCluster`].Value' --output text --region ${AWS_REGION}"
            sh """
            #!/bin/bash
            task_def=${task_def}
            cluster=${cluster}
            chmod +x ./ecs-run.sh
            ./ecs-run.sh -c \$cluster -d \$task_def -n schema -r ${AWS_REGION}
            """
          }
        }
      }
    }
    stage('Update Dev Environment') {
      when {
        expression { env.BRANCH_NAME == 'development' || env.BRANCH_NAME == 'feature/jenkinsfile' }
      }
      steps {
        println "Updating Dev Environment"
        cloudformation(
          stackName: 'dev-{{ project }}',
          action: 'create',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}/${env.cf_version}/${env.PROJECT_NAME}.compiled.yaml",
          accountId: env.DEV_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'EnvironmentName': 'dev',
            'EnvironmentType': 'development',
            'DnsDomain': env.DNS_DOMAIN,
            'ApiTag': env.GIT_COMMIT,
            'NginxTag': env.GIT_COMMIT,
            'WorkerTag': env.GIT_COMMIT,
            'CronTag': env.GIT_COMMIT
          ]
        )
        cloudformation(
          stackName: 'dev-{{ project }}',
          action: 'update',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}/${env.cf_version}/${env.PROJECT_NAME}.compiled.yaml",
          accountId: env.DEV_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'ApiTag': env.GIT_COMMIT,
            'NginxTag': env.GIT_COMMIT,
            'WorkerTag': env.GIT_COMMIT,
            'CronTag': env.GIT_COMMIT
          ]
        )
      }
    }
    stage('Update UAT Schema Environment') {
      when {
        expression { env.BRANCH_NAME == 'master' && params.UPDATE_SCHEMA_TASK_DEF == true }
      }
      steps {
        println "Update Schema Task Def UAT Environment"
        sh "export"
        cloudformation(
          stackName: 'uat-{{ project }}-schema',
          action: 'create',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}-schema/${env.cf_version}/${env.PROJECT_NAME}-schema.compiled.yaml",
          accountId: env.PROD_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'EnvironmentName': 'uat',
            'EnvironmentType': 'production'
          ]
        )
        cloudformation(
          stackName: 'uat-{{ project }}-schema',
          action: 'update',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}-schema/${env.cf_version}/${env.PROJECT_NAME}-schema.compiled.yaml",
          accountId: env.PROD_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'EnvironmentName': 'uat',
            'EnvironmentType': 'production'
          ]
        )
      }
    }
    stage('Update UAT Schema') {
      environment {
        ENV = "uat"
      }
      when {
        expression { env.BRANCH_NAME == 'master' && params.UPDATE_SCHEMA == true }
      }
      steps {
        println "Updating Schema"
        sh '''
        #!/bin/bash
        aws s3 cp s3://${SOURCE_BUCKET}/scripts/ecs-run-fargate.sh ecs-run-fargate.sh
        chmod +x ./ecs-run-fargate.sh
        '''
        withAWS(roleAccount:env.PROD_ACCOUNT_ID, region:env.AWS_REGION, role:env.CIINABOX_ROLE) {
          script {
            def task_def = sh returnStdout: true, script: "aws cloudformation list-exports --query 'Exports[?Name==`${ENV}-{{ project }}-schema-task-EcsTaskArn`].Value' --output text --region ${AWS_REGION}"
            def cluster = sh returnStdout: true, script: "aws cloudformation list-exports --query 'Exports[?Name==`${ENV}-ecs-EcsCluster`].Value' --output text --region ${AWS_REGION}"
            sh """
            #!/bin/bash
            task_def=${task_def}
            cluster=${cluster}
            chmod +x ./ecs-run.sh
            ./ecs-run.sh -c \$cluster -d \$task_def -n schema -r ${AWS_REGION}
            """
          }
        }
      }
    }
    stage('Update UAT Environment') {
      when {
        expression { env.BRANCH_NAME == 'master' }
      }
      steps {
        println "Updating uat Environment"
        cloudformation(
          stackName: 'uat-{{ project }}',
          action: 'create',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}/${env.cf_version}/${env.PROJECT_NAME}.compiled.yaml",
          accountId: env.PROD_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'EnvironmentName': 'uat',
            'EnvironmentType': 'production',
            'DnsDomain': env.DNS_DOMAIN,
            'ApiTag': env.GIT_COMMIT,
            'NginxTag': env.GIT_COMMIT,
            'WorkerTag': env.GIT_COMMIT,
            'CronTag': env.GIT_COMMIT
          ]
        )
        cloudformation(
          stackName: 'uat-{{ project }}',
          action: 'update',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}/${env.cf_version}/${env.PROJECT_NAME}.compiled.yaml",
          accountId: env.PROD_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'ApiTag': env.GIT_COMMIT,
            'NginxTag': env.GIT_COMMIT,
            'WorkerTag': env.GIT_COMMIT,
            'CronTag': env.GIT_COMMIT
          ]
        )
      }
    }
    stage('Deploy to production') {
      when {
        expression { env.BRANCH_NAME == 'master' }
      }
      steps {
        timeout(time: 120, unit: 'MINUTES') {
            script {
                input( message: 'Deploy to prod?' )
            }
        }
      }
    }
    stage('Update prod Schema Environment') {
      when {
        expression { env.BRANCH_NAME == 'master' && params.UPDATE_SCHEMA_TASK_DEF == true }
      }
      steps {
        println "Update Schema Task Def prod Environment"
        sh "export"
        cloudformation(
          stackName: 'prod-{{ project }}-schema',
          action: 'create',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}-schema/${env.cf_version}/${env.PROJECT_NAME}-schema.compiled.yaml",
          accountId: env.PROD_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'EnvironmentName': 'prod',
            'EnvironmentType': 'production'
          ]
        )
        cloudformation(
          stackName: 'prod-{{ project }}-schema',
          action: 'update',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}-schema/${env.cf_version}/${env.PROJECT_NAME}-schema.compiled.yaml",
          accountId: env.PROD_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'EnvironmentName': 'prod',
            'EnvironmentType': 'production'
          ]
        )
      }
    }
    stage('Update prod Schema') {
      environment {
        ENV = "prod"
      }
      when {
        expression { env.BRANCH_NAME == 'master' && params.UPDATE_SCHEMA == true }
      }
      steps {
        println "Updating Schema"
        sh '''
        #!/bin/bash
        aws s3 cp s3://${SOURCE_BUCKET}/scripts/ecs-run.sh ecs-run.sh
        chmod +x ./ecs-run.sh
        '''
        withAWS(roleAccount:env.PROD_ACCOUNT_ID, region:env.AWS_REGION, role:env.CIINABOX_ROLE) {
          script {
            def task_def = sh returnStdout: true, script: "aws cloudformation list-exports --query 'Exports[?Name==`${ENV}-{{ project }}-schema-task-EcsTaskArn`].Value' --output text --region ${AWS_REGION}"
            def cluster = sh returnStdout: true, script: "aws cloudformation list-exports --query 'Exports[?Name==`${ENV}-ecs-EcsCluster`].Value' --output text --region ${AWS_REGION}"
            sh """
            #!/bin/bash
            task_def=${task_def}
            cluster=${cluster}
            chmod +x ./ecs-run.sh
            ./ecs-run.sh -c \$cluster -d \$task_def -n schema -r ${AWS_REGION}
            """
          }
        }
      }
    }
    stage('Update prod Environment') {
      when {
        expression { env.BRANCH_NAME == 'master' }
      }
      steps {
        println "Updating PROD Environment"
        cloudformation(
          stackName: 'prod-{{ project }}',
          action: 'create',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}/${env.cf_version}/${env.PROJECT_NAME}.compiled.yaml",
          accountId: env.PROD_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'EnvironmentName': 'prod',
            'EnvironmentType': 'production',
            'DnsDomain': env.DNS_DOMAIN,
            'ApiTag': env.GIT_COMMIT,
            'NginxTag': env.GIT_COMMIT,
            'WorkerTag': env.GIT_COMMIT,
            'CronTag': env.GIT_COMMIT
          ]
        )
        cloudformation(
          stackName: 'prod-{{ project }}',
          action: 'update',
          region: env.AWS_REGION,
          templateUrl: "https://s3-${env.AWS_REGION}.amazonaws.com/${env.SOURCE_BUCKET}/cloudformation/${env.PROJECT_NAME}/${env.cf_version}/${env.PROJECT_NAME}.compiled.yaml",
          accountId: env.PROD_ACCOUNT_ID,
          role: env.CIINABOX_ROLE,
          parameters: [
            'ApiTag': env.GIT_COMMIT,
            'NginxTag': env.GIT_COMMIT,
            'WorkerTag': env.GIT_COMMIT,
            'CronTag': env.GIT_COMMIT
          ]
        )
      }
    }
  }
  post {
      success {
        slackInfo "SUCCESS"
      }
      unstable {
        slackWarning "UNSTABLE"
      }
      failure {
        slackError "!!! FAILED !!!"
      }
      always {
            deleteDir()
        }
  }
}
